// Google FlatBuffers IDL for efficient, zero-copy serialized data columns
// http://google.github.io/flatbuffers/index.html
//
// Please stick to FlatBuffers versioning guide for backwards compatibility

namespace org.velvia.filo.column;

// All columns have a bitmask for representing NA values.
// AllZeroes = every value is available;  AllOnes = no value is available == empty
enum MaskType : byte { AllZeroes, SimpleBitMask, AllOnes }

table NaMask {
  maskType: MaskType = AllOnes;
  /// for type = SimpleBitMask
  bitMask: [long];
}

// --- vectors holding either the original data, or the dictionary encoding ---
table IntVector {
  data: [int];
}

table ShortVector {
  data: [short];
}

// Whether data in a byteVector is really 8-bits, 4-bits, or 1-bit wide
enum ByteDataType : byte { TByte, TNibble, TBit }

table ByteVector {
  dataType: ByteDataType = TByte;
  data: [byte];
}

table LongVector {
  data: [long];
}

table FloatVector {
  data: [float];
}

table DoubleVector {
  data: [double];
}

table StringVector {
  data: [string];
}

union AnyVector { ByteVector, ShortVector, IntVector, LongVector, FloatVector, DoubleVector, StringVector }

// The Simple* types are optimized for very few NA values.  If most values are missing, we might
// want a very different representation.
table SimpleColumn {
  naMask: NaMask;
  vector: AnyVector;
}

// Dictionary encoded string column, with NA/missing value support
// The 0 value for a code is reserved for NA.  This means dictionary size is actually 1 + (# uniques).
// In most cases, this results in smaller binaries (no naMask)
table DictStringColumn {
  dictionary: [string];
  codes: AnyVector;
}

union AnyColumn { SimpleColumn, DictStringColumn }

table Column {
  col: AnyColumn (required);
}

root_type Column;